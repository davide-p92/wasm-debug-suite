use anyhow::{anyhow, Result};

pub fn gen_rust_host_bindings(wit_path: &str, world: &str) -> Result<String> {

    Ok(format!(r#"// Auto-generated by didspace bindgen
// Host bindings for a WebAssembly Component (Wasmtime)

use wasmtime::component::bindgen;

bindgen!({{
    path: "{wit_path}",
    world: "{world}",
}});

// Tip: set WASMTIME_DEBUG_BINDGEN=1 to dump generated code if you debug compile errors.
"#))
}

pub fn gen_ts_node_wrapper(world: &str) -> Result<String> {
    // world qui lo usi per dare un nome “carino” al tipo.
    // Non serve conoscere WIT per MVP.
    let type_name = pascal_case(world);

    Ok(format!(r#"// Auto-generated by didspace bindgen (Node.js + Jco)
//
// 1) Generate JS glue into ./generated:
//    npx @bytecodealliance/jco transpile ./component.wasm -o ./generated
//
// 2) Use this wrapper from Node/TS:
//
//    import {{ load }} from "./bindings";
//    const api = await load();
//    await api.hello?.(); // if exported
//

import * as component from "./generated/component.js";

/**
 * Minimal typed facade.
 * (MVP) We don't derive exact types from WIT yet.
 */
export type {type_name} = Record<string, any>;

export async function load(): Promise<{type_name}> {{
  // Jco default ESM mode exports the component exports directly from component.js
  // See: import {{ fn }} from './generated/component.js'
  return component as unknown as {type_name};
}}

"#))
}

fn pascal_case(s: &str) -> String {
    s.split(|c: char| c == '-' || c == '_' || c == ' ')
        .filter(|p| !p.is_empty())
        .map(|p| {
            let mut ch = p.chars();
            match ch.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + ch.as_str(),
            }
        })
        .collect()
}
